
--------------------1]FCFS non-premptive---------------------------------

#include <stdio.h>

int main() {
    int bt[20], wt[20], tat[20], i, n; 
    float wtavg, tatavg;

    printf("\nEnter the number of processes -- "); 
    scanf("%d", &n);

    // Input burst times for each process
    for(i = 0; i < n; i++) {
        printf("\nEnter Burst Time for Process %d -- ", i); 
        scanf("%d", &bt[i]);
    }

    // Initialize waiting time and turnaround time for the first process
    wt[0] = 0;
    tat[0] = bt[0];
    wtavg = 0;
    tatavg = tat[0];

    // Calculate waiting time and turnaround time for each process
    for(i = 1; i < n; i++) {
        wt[i] = wt[i - 1] + bt[i - 1];  // Waiting time of current process
        tat[i] = wt[i] + bt[i];         // Turnaround time of current process
        wtavg += wt[i]; 
        tatavg += tat[i];
    }

    // Display table with process information
    printf("\n\tPROCESS\t\tBURST TIME\tWAITING TIME\tTURNAROUND TIME\n");
    for(i = 0; i < n; i++) {
        printf("\tP%d\t\t%d\t\t%d\t\t%d\n", i, bt[i], wt[i], tat[i]);
    }

    // Calculate and display average waiting and turnaround times
    printf("\nAverage Waiting Time -- %.2f", wtavg / n); 
    printf("\nAverage Turnaround Time -- %.2f\n", tatavg / n);

    return 0;
}
-------------------------------------------1]FCFS pre emptive--------------------------------------------
#include <stdio.h>

int main()
{
    int bt[20], wt[20], tat[20], ct[20], at[20];
    int i, n;
    float wtavg = 0, tatavg = 0;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    for (i = 0; i < n; i++)
    {
        printf("Enter Arrival Time for Process %d: ", i + 1);
        scanf("%d", &at[i]);
        printf("Enter Burst Time for Process %d: ", i + 1);
        scanf("%d", &bt[i]);
    }

    ct[0] = at[0] + bt[0];
    tat[0] = ct[0] - at[0];
    wt[0] = tat[0] - bt[0];
    wtavg += wt[0];
    tatavg += tat[0];

    for (i = 1; i < n; i++)
    {
        if (at[i] > ct[i - 1])
            ct[i] = at[i] + bt[i];
        else
            ct[i] = ct[i - 1] + bt[i];

        tat[i] = ct[i] - at[i];
        wt[i] = tat[i] - bt[i];
        wtavg += wt[i];
        tatavg += tat[i];
    }

    printf("\nPROCESS\t\tARRIVAL TIME\tBURST TIME\tCOMPLETION TIME\tTURNAROUND TIME\tWAITING TIME\n");
    for (i = 0; i < n; i++)
    {
        printf("\nP%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d", i + 1, at[i], bt[i], ct[i], tat[i], wt[i]);
    }
    
    printf("\n\nAverage Waiting Time: %.2f", wtavg / n);
    printf("\nAverage Turnaround Time: %.2f\n", tatavg / n);

    return 0;
}

 -----------------------------------------2]priority -non-preemptive algo in c----------------------------
 #include <stdio.h>

struct Process {
    int pid;        // Process ID
    int burstTime;  // Burst Time
    int priority;   // Priority
    int waitingTime;    // Waiting Time
    int turnAroundTime; // Turnaround Time
};

void calculateTimes(struct Process proc[], int n) {
    int totalWaitingTime = 0, totalTurnAroundTime = 0;

    // Calculate Waiting Time for each process
    proc[0].waitingTime = 0; // First process has 0 waiting time
    for (int i = 1; i < n; i++) {
        proc[i].waitingTime = proc[i - 1].waitingTime + proc[i - 1].burstTime;
    }

    // Calculate Turnaround Time for each process
    for (int i = 0; i < n; i++) {
        proc[i].turnAroundTime = proc[i].waitingTime + proc[i].burstTime;
        totalWaitingTime += proc[i].waitingTime;
        totalTurnAroundTime += proc[i].turnAroundTime;
    }

    printf("\nProcess\tPriority\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t%d\t\t%d\t\t%d\t\t%d\n", proc[i].pid, proc[i].priority, proc[i].burstTime, proc[i].waitingTime, proc[i].turnAroundTime);
    }

    printf("\nAverage Waiting Time: %.2f", (float)totalWaitingTime / n);
    printf("\nAverage Turnaround Time: %.2f\n", (float)totalTurnAroundTime / n);
}

void priorityScheduling(struct Process proc[], int n) {
    // Sort processes by priority (lower number indicates higher priority)
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (proc[i].priority > proc[j].priority) {
                struct Process temp = proc[i];
                proc[i] = proc[j];
                proc[j] = temp;
            }
        }
    }

    calculateTimes(proc, n);
}

int main() {
    int n;
    printf("Enter the number of processes: ");
    scanf("%d", &n);

    struct Process proc[n];

    for (int i = 0; i < n; i++) {
        proc[i].pid = i + 1;
        printf("Enter Burst Time for Process %d: ", i + 1);
        scanf("%d", &proc[i].burstTime);
        printf("Enter Priority for Process %d: ", i + 1);
        scanf("%d", &proc[i].priority);
    }

    priorityScheduling(proc, n);

    return 0;
}

 --------------------------3]Round Robin Algorithm-------------------------------------------------
 #include <stdio.h>

int main() {
    int i, n, t, time = 0, remainingProcesses;
    int bu[10], wa[10] = {0}, tat[10] = {0}, remainingTime[10];
    float awt = 0, att = 0;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    // Input burst times for each process
    for(i = 0; i < n; i++) {
        printf("Enter Burst Time for Process %d: ", i + 1);
        scanf("%d", &bu[i]);
        remainingTime[i] = bu[i];  // Set remaining time for each process
    }

    printf("Enter the size of time slice: ");
    scanf("%d", &t);

    remainingProcesses = n;

    // Round Robin Logic
    while (remainingProcesses > 0) {
        for (i = 0; i < n; i++) {
            if (remainingTime[i] > 0) { // Process is still remaining
                if (remainingTime[i] <= t) {
                    // Process finishes within this time slice
                    time += remainingTime[i];
                    tat[i] = time; // Turnaround time is total time at finish
                    remainingTime[i] = 0; // Process is complete
                    remainingProcesses--; // Decrement count of processes left
                } else {
                    // Process runs for a full time slice, but is not complete
                    time += t;
                    remainingTime[i] -= t; // Decrement remaining time
                }
            }
        }
    }

    // Calculate waiting time and average turnaround/waiting time
    for(i = 0; i < n; i++) {
        wa[i] = tat[i] - bu[i];
        att += tat[i];
        awt += wa[i];
    }
    att /= n;
    awt /= n;

    // Display results
    printf("\nPROCESS\tBURST TIME\tWAITING TIME\tTURNAROUND TIME\n");
    for(i = 0; i < n; i++) {
        printf("%d\t%d\t\t%d\t\t%d\n", i + 1, bu[i], wa[i], tat[i]);
    }

    printf("\nAverage Waiting Time: %.2f", awt);
    printf("\nAverage Turnaround Time: %.2f\n", att);

    return 0;
}
------------------------------------4]SJF (pre emptive)C--------------------------- 
#include <stdio.h>
#include <limits.h>

int main() {
    int bt[20], wt[20], tat[20], ct[20], at[20], remaining_bt[20], n, i, j, t = 0;
    float wtavg = 0, tatavg = 0;

    // Input number of processes
    printf("Enter the number of processes: ");
    scanf("%d", &n);

    // Input arrival time and burst time for each process
    for (i = 0; i < n; i++) {
        printf("Enter Arrival Time for Process %d: ", i+1);
        scanf("%d", &at[i]);
        printf("Enter Burst Time for Process %d: ", i+1);
        scanf("%d", &bt[i]);
        remaining_bt[i] = bt[i];  // Initialize remaining burst time
    }

    int completed = 0, min_bt, shortest, finish_time;
    int check[n];  // To check if the process is completed
    for (i = 0; i < n; i++) check[i] = 0;  // Initialize check array to 0

    // Main scheduling loop
    while (completed < n) {
        min_bt = INT_MAX;
        shortest = -1;

        // Find process with minimum burst time that has arrived and not completed
        for (i = 0; i < n; i++) {
            if (at[i] <= t && !check[i] && remaining_bt[i] < min_bt && remaining_bt[i] > 0) {
                min_bt = remaining_bt[i];
                shortest = i;
            }
        }

        if (shortest == -1) {
            t++; // If no process is ready to execute, increment time
            continue;
        }

        // Execute the selected process for one time unit
        remaining_bt[shortest]--;
        t++;

        // If the process is completed
        if (remaining_bt[shortest] == 0) {
            check[shortest] = 1;
            completed++;
            finish_time = t;
            ct[shortest] = finish_time;
            tat[shortest] = ct[shortest] - at[shortest];
            wt[shortest] = tat[shortest] - bt[shortest];
            wtavg += wt[shortest];
            tatavg += tat[shortest];
        }
    }

    // Output process information
    printf("\nPROCESS \tARRIVAL TIME \tBURST TIME \tCOMPLETION TIME \tTURNAROUND TIME \tWAITING TIME\n");
    for (i = 0; i < n; i++) {
        printf("\n\t P%d\t\t %d\t\t %d\t\t %d\t\t %d\t\t %d", i + 1, at[i], bt[i], ct[i], tat[i], wt[i]);
    }

    // Calculate and display average waiting time and turnaround time
    printf("\nAverage Waiting Time -- %.2f", wtavg / n);
    printf("\nAverage Turnaround Time -- %.2f", tatavg / n);

    return 0;
}
-----------------------4]SJF c++---------------------------------------------------
#include <iostream>
#include <climits>
using namespace std;

int main() {
    int bt[20], wt[20], tat[20], ct[20], at[20], remaining_bt[20], n, i, j, t = 0;
    float wtavg = 0, tatavg = 0;
    
    cout << "Enter the number of processes: ";
    cin >> n;

    for (i = 0; i < n; i++) {
        cout << "Enter Arrival Time for Process " << i+1 << ": ";
        cin >> at[i];
        cout << "Enter Burst Time for Process " << i+1 << ": ";
        cin >> bt[i];
        remaining_bt[i] = bt[i];  // Initialize remaining burst time
    }

    int completed = 0, min_bt, shortest, finish_time;
    bool check[n] = {0}; // To check if the process is completed

    while (completed < n) {
        min_bt = INT_MAX;
        shortest = -1;

        // Find process with minimum burst time that has arrived and not completed
        for (i = 0; i < n; i++) {
            if (at[i] <= t && !check[i] && remaining_bt[i] < min_bt && remaining_bt[i] > 0) {
                min_bt = remaining_bt[i];
                shortest = i;
            }
        }

        if (shortest == -1) {
            t++; // If no process is ready to execute, increment time
            continue;
        }

        // Execute the selected process for one time unit
        remaining_bt[shortest]--;
        t++;

        // If the process is completed
        if (remaining_bt[shortest] == 0) {
            check[shortest] = 1;
            completed++;
            finish_time = t;
            ct[shortest] = finish_time;
            tat[shortest] = ct[shortest] - at[shortest];
            wt[shortest] = tat[shortest] - bt[shortest];
            wtavg += wt[shortest];
            tatavg += tat[shortest];
        }
    }

    cout << "\nPROCESS \tARRIVAL TIME \tBURST TIME \tCOMPLETION TIME \tTURNAROUND TIME \tWAITING TIME\n";
    for (i = 0; i < n; i++) {
        cout << "\n\t P" << i << "\t\t " << at[i] << "\t\t " << bt[i] << "\t\t " << ct[i] << "\t\t " << tat[i] << "\t\t " << wt[i];
    }

    cout << "\nAverage Waiting Time -- " << wtavg / n;
    cout << "\nAverage Turnaround Time -- " << tatavg / n;

    return 0;
}
--------------------------------5]Firstfit C--------------------------------------------
#include <stdio.h>

#define max 25

int main() {
    int frag[max], b[max], f[max], i, j, nb, nf, temp;
    static int bf[max], ff[max];

    // Get the number of blocks and files
    printf("\n\tMemory Management Scheme - First Fit\n");
    printf("\nEnter the number of blocks: ");
    scanf("%d", &nb);
    printf("Enter the number of files: ");
    scanf("%d", &nf);

    // Input block sizes
    printf("\nEnter the size of the blocks:-\n");
    for (i = 0; i < nb; i++) {
        printf("Block %d: ", i + 1);
        scanf("%d", &b[i]);
    }

    // Input file sizes
    printf("Enter the size of the files :-\n");
    for (i = 0; i < nf; i++) {
        printf("File %d: ", i + 1);
        scanf("%d", &f[i]);
    }

    // First-fit allocation
    for (i = 0; i < nf; i++) {
        for (j = 0; j < nb; j++) {
            if (bf[j] != 1) { // Block is not allocated
                temp = b[j] - f[i];  // Calculate the remaining space in the block
                if (temp >= 0) {  // File fits in the block
                    ff[i] = j;  // Allocate this block to the file
                    break;
                }
            }
        }

        frag[i] = b[ff[i]] - f[i];  // Calculate fragmentation
        bf[ff[i]] = 1;  // Mark the block as allocated
    }

    // Display the allocation details
    printf("\nFile_no:\tFile_size :\tBlock_no:\tBlock_size:\tFragmentation\n");
    for (i = 0; i < nf; i++) {
        printf("%d\t\t%d\t\t%d\t\t%d\t\t%d\n", i + 1, f[i], ff[i] + 1, b[ff[i]], frag[i]);
    }

    return 0;
}
--------------------------------------6]Worst fit algorithm -----------------------------------------------------
#include<stdio.h>

#define max 25

int main() {
    int frag[max], b[max], f[max], i, j, nb, nf, temp, lowest, ff[max];
    static int bf[max];  // Block flags, to keep track of allocated blocks
    
    // Get the number of blocks and files
    printf("\nEnter the number of blocks: ");
    scanf("%d", &nb);
    printf("Enter the number of files: ");
    scanf("%d", &nf);
    
    // Input block sizes
    printf("\nEnter the size of the blocks:-\n");
    for(i = 0; i < nb; i++) {
        printf("Block %d: ", i + 1);
        scanf("%d", &b[i]);
    }

    // Input file sizes
    printf("Enter the size of the files :-\n");
    for(i = 0; i < nf; i++) {
        printf("File %d: ", i + 1);
        scanf("%d", &f[i]);
    }

    // Allocation using Worst Fit
    for(i = 0; i < nf; i++) {
        lowest = -1; // Reset lowest for each file allocation
        for(j = 0; j < nb; j++) {
            if(bf[j] != 1) {  // Block is not allocated
                temp = b[j] - f[i];  // Calculate remaining space in block
                if(temp >= 0 && (lowest == -1 || temp > b[lowest] - f[i])) {
                    ff[i] = j;  // Allocate this block to the file
                    lowest = j;  // Track the block with the largest remaining space
                }
            }
        }
        
        if(lowest != -1) {  // If a block is found
            frag[i] = b[ff[i]] - f[i];  // Calculate fragmentation
            bf[ff[i]] = 1;  // Mark the block as allocated
        } else {
            frag[i] = -1;  // No block found for this file
        }
    }

    // Display the allocation details
    printf("\nFile No\tFile Size \tBlock No\tBlock Size\tFragment\n");
    for(i = 0; i < nf; i++) {
        if(frag[i] != -1) {
            printf("%d\t\t%d\t\t%d\t\t%d\t\t%d\n", i + 1, f[i], ff[i] + 1, b[ff[i]], frag[i]);
        } else {
            printf("%d\t\t%d\t\tNot Allocated\t-\t\t-\n", i + 1, f[i]);
        }
    }

    return 0;
}
---------------------------------7]Best fit in C-----------------------------------------
#include<stdio.h>

#define MAX 25

int main() {
    int frag[MAX], b[MAX], f[MAX], i, j, nb, nf, temp, best, ff[MAX];
    static int bf[MAX];  // Block flags to mark allocated blocks

    // Get the number of blocks and files
    printf("\nEnter the number of blocks: ");
    scanf("%d", &nb);
    printf("Enter the number of files: ");
    scanf("%d", &nf);

    // Input block sizes
    printf("\nEnter the size of the blocks:-\n");
    for(i = 0; i < nb; i++) {
        printf("Block %d: ", i + 1);
        scanf("%d", &b[i]);
    }

    // Input file sizes
    printf("Enter the size of the files :-\n");
    for(i = 0; i < nf; i++) {
        printf("File %d: ", i + 1);
        scanf("%d", &f[i]);
    }

    // Allocation using Best Fit
    for(i = 0; i < nf; i++) {
        best = -1;  // Reset best block for each file allocation
        for(j = 0; j < nb; j++) {
            if(bf[j] != 1) {  // Block is not allocated
                temp = b[j] - f[i];  // Calculate remaining space in block
                if(temp >= 0 && (best == -1 || temp < b[best] - f[i])) {
                    ff[i] = j;  // Allocate this block to the file
                    best = j;  // Track the block with the least remaining space
                }
            }
        }

        if(best != -1) {  // If a block is found
            frag[i] = b[ff[i]] - f[i];  // Calculate fragmentation
            bf[ff[i]] = 1;  // Mark the block as allocated
        } else {
            frag[i] = -1;  // No block found for this file
        }
    }

    // Display the allocation details
    printf("\nFile No\tFile Size \tBlock No\tBlock Size\tFragment\n");
    for(i = 0; i < nf; i++) {
        if(frag[i] != -1) {
            printf("%d\t\t%d\t\t%d\t\t%d\t\t%d\n", i + 1, f[i], ff[i] + 1, b[ff[i]], frag[i]);
        } else {
            printf("%d\t\t%d\t\tNot Allocated\t-\t\t-\n", i + 1, f[i]);
        }
    }

    return 0;
}
-----------------------8]FiFO page exhange algo------------------------------------------------
#include <stdio.h>

int main() {
    int referenceString[25], frames[10], numPages, numFrames;
    int pageFaults = 0, currentIndex = 0;
    
    // Input the length of the reference string
    printf("Enter the number of pages in the reference string: ");
    scanf("%d", &numPages);

    // Input the reference string
    printf("Enter the reference string: ");
    for (int i = 0; i < numPages; i++) {
        scanf("%d", &referenceString[i]);
    }

    // Input the number of frames
    printf("Enter the number of frames: ");
    scanf("%d", &numFrames);

    // Initialize frames with -1 (indicating empty frames)
    for (int i = 0; i < numFrames; i++) {
        frames[i] = -1;
    }

    // Start the page replacement process
    printf("\nPage Replacement Process (FIFO):\n");
    for (int i = 0; i < numPages; i++) {
        int page = referenceString[i];
        int isPageFault = 1;

        // Check if page is already in one of the frames (no page fault if found)
        for (int j = 0; j < numFrames; j++) {
            if (frames[j] == page) {
                isPageFault = 0;
                break;
            }
        }

        // If page is not found in frames, it's a page fault
        if (isPageFault) {
            frames[currentIndex] = page;           // Replace page at the currentIndex position (FIFO order)
            currentIndex = (currentIndex + 1) % numFrames; // Move to next frame in circular FIFO order
            pageFaults++;
        }

        // Display the current state of frames and indicate a page fault if it occurred
        printf("Page %d:\t", page);
        for (int j = 0; j < numFrames; j++) {
            if (frames[j] != -1) {
                printf("%d\t", frames[j]);
            } else {
                printf("-\t");
            }
        }
        if (isPageFault) {
            printf(" (Page Fault #%d)", pageFaults);
        }
        printf("\n");
    }

    // Final page fault count
    printf("\nTotal Page Faults: %d\n", pageFaults);

    return 0;
}
--------------------------9]LRU-----------------------------------------------------
#include <stdio.h>

int main() {
    int referenceString[25], frames[10], count[10], flag[25];
    int numPages, numFrames, pageFaults = 0, next = 1;

    // Input length of the reference string
    printf("Enter the length of reference string: ");
    scanf("%d", &numPages);

    // Input reference string
    printf("Enter the reference string: ");
    for (int i = 0; i < numPages; i++) {
        scanf("%d", &referenceString[i]);
        flag[i] = 0;  // Initialize flags to 0 for tracking if page is in frame
    }

    // Input the number of frames
    printf("Enter the number of frames: ");
    scanf("%d", &numFrames);

    // Initialize frames and count
    for (int i = 0; i < numFrames; i++) {
        frames[i] = -1;  // Empty frame initialization
        count[i] = 0;    // Initialize count array for LRU
    }

    // Page replacement process
    printf("\nThe Page Replacement Process is:\n");
    for (int i = 0; i < numPages; i++) {
        int page = referenceString[i];
        int found = 0;

        // Check if page is already in one of the frames
        for (int j = 0; j < numFrames; j++) {
            if (frames[j] == page) {
                found = 1;          // Page hit
                count[j] = next++;  // Update counter for LRU
                break;
            }
        }

        // Page fault handling
        if (!found) {
            if (i < numFrames) {
                // Initially fill empty frames
                frames[i] = page;
                count[i] = next++;
            } else {
                // Find the least recently used page (minimum count)
                int lruIndex = 0;
                for (int j = 1; j < numFrames; j++) {
                    if (count[j] < count[lruIndex]) {
                        lruIndex = j;
                    }
                }
                // Replace the LRU page
                frames[lruIndex] = page;
                count[lruIndex] = next++;
            }
            pageFaults++;
        }

        // Display current frame state
        printf("Page %d:\t", page);
        for (int j = 0; j < numFrames; j++) {
            if (frames[j] != -1) {
                printf("%d\t", frames[j]);
            } else {
                printf("-\t");
            }
        }
        if (!found) {
            printf(" (Page Fault #%d)", pageFaults);
        }
        printf("\n");
    }

    // Total page faults
    printf("\nTotal Page Faults using LRU: %d\n", pageFaults);

    return 0;
}
------------------------------10]LFU page rplaCement-----------------------------------
 #include <stdio.h>

int main() {
    int referenceString[50], frames[20], counter[20];
    int numPages, numFrames, pageFaults = 0;

    // Input: Number of page references
    printf("Enter the number of page references: ");
    scanf("%d", &numPages);

    // Input: Reference string
    printf("Enter the reference string: ");
    for (int i = 0; i < numPages; i++) {
        scanf("%d", &referenceString[i]);
    }

    // Input: Number of frames
    printf("Enter the number of frames: ");
    scanf("%d", &numFrames);

    // Initialize frames and counters
    for (int i = 0; i < numFrames; i++) {
        frames[i] = -1;    // Indicates empty frame
        counter[i] = 0;    // Counter to track usage for LFU
    }

    // Page Replacement Process
    printf("\nThe Page Replacement Process is:\n");
    for (int i = 0; i < numPages; i++) {
        int currentPage = referenceString[i];
        int found = 0;  // To check if page is already in frame

        // Check if page is already in one of the frames
        for (int j = 0; j < numFrames; j++) {
            if (frames[j] == currentPage) {
                counter[j]++;  // Increment usage count
                found = 1;
                break;
            }
        }

        // If page is not found, handle page fault
        if (!found) {
            int minIndex = 0;

            // Find the frame with the minimum counter (LFU)
            for (int j = 1; j < numFrames; j++) {
                if (counter[j] < counter[minIndex]) {
                    minIndex = j;
                }
            }

            // Replace the least frequently used page
            frames[minIndex] = currentPage;
            counter[minIndex] = 1;  // Reset the usage count for the new page
            pageFaults++;
        }

        // Display current frame status
        printf("Page %d:\t", currentPage);
        for (int j = 0; j < numFrames; j++) {
            if (frames[j] != -1) {
                printf("%d\t", frames[j]);
            } else {
                printf("-\t");
            }
        }

        if (!found) {
            printf("(Page Fault #%d)", pageFaults);
        }
        printf("\n");
    }

    // Total page faults
    printf("\nTotal number of page faults: %d\n", pageFaults);

    return 0;
}
------------------------11]pass-1 assembler--------------------------------------------
 class SymTab {
    int index;
    String name;
    int addr;

    SymTab(int i, String s, int a) {
        index = i;
        name = s;
        addr = a;
    }
}

class LitTab {
    int index;
    String name;
    int addr;

    LitTab(int i, String a, int addr) {
        index = i;
        name = a;
        this.addr = addr;
    }

    void setAddr(int a) {
        addr = a;
    }
}

class PoolTab {
    int pIndex;
    int lIndex;

    PoolTab(int i, int a) {
        pIndex = i;
        lIndex = a;
    }
}

public class Pass1 {
    public static void main(String[] args) {
        String[][] input = {
            {null, "START", "100", null},
            {null, "MOVER", "AREG", "A"},
            {"AGAIN", "ADD", "AREG", "='2"},
            {null, "ADD", "AREG", "B"},
            {"AGAIN", "ADD", "AREG", "='3"},
            {null, "LTORG", null, null},
            {"AGAIN2", "ADD", "AREG", "BREG"},
            {"AGAIN2", "ADD", "AREG", "CREG"},
            {"AGAIN", "ADD", "AREG", "='2"},
            {null, "DC", "B", "3"},
            {"LOOP", "DS", "A", "1"},
            {null, "END", null, null}
        };

        SymTab[] symTab = new SymTab[20];
        LitTab[] litTab = new LitTab[20];
        PoolTab[] poolTab = new PoolTab[20];

        int loc = Integer.parseInt(input[0][2]);
        int i = 1, sn = 0, ln = 0, Inc = 0, pn = 0;
        String m = input[1][1];

        while (!m.equals("END")) {
            if (check(m) == 1) {
                if (input[i][0] == null) {
                    String op1 = input[i][2];
                    String op2 = input[i][3];
                    if (comp(op2, symTab, sn) == 1) {
                        symTab[sn] = new SymTab(sn, op2, 0);
                        sn++;
                    } else if (comp(op2, symTab, sn) == 2) {
                        litTab[ln] = new LitTab(ln, op2, 0);
                        ln++;
                    }
                    loc++;
                    i++;
                } else {
                    String op1 = input[i][0];
                    symTab[sn] = new SymTab(sn, op1, loc);
                    sn++;
                    String op2 = input[i][3];
                    if (comp(op2, symTab, sn) == 1) {
                        symTab[sn] = new SymTab(sn, op2, 0);
                        sn++;
                    } else if (comp(op2, symTab, sn) == 2) {
                        litTab[ln] = new LitTab(ln, op2, 0);
                        ln++;
                    }
                    loc++;
                    i++;
                }
            } else if (check(m) == 2) {
                if (input[i][0] == null) {
                    String op1 = input[i][2];
                    String op2 = input[i][3];
                    int temp = comp(op1, symTab, sn);
                    if (temp != 99) {
                        symTab[temp] = new SymTab(temp, op1, loc);
                    }
                    loc += Integer.parseInt(op2);
                    i++;
                } else {
                    String op1 = input[i][0];
                    symTab[sn] = new SymTab(sn, op1, loc);
                    sn++;
                    String op2 = input[i][3];
                    int temp = comp(op1, symTab, sn);
                    if (temp != 99) {
                        symTab[temp] = new SymTab(temp, op1, loc);
                    }
                    loc += Integer.parseInt(op2);
                    i++;
                }
            } else if (check(m) == 3) {
                if (input[i][0] == null) {
                    String op1 = input[i][2];
                    String op2 = input[i][3];
                    int temp = comp(op1, symTab, sn);
                    if (temp != 99) {
                        symTab[temp] = new SymTab(temp, op1, loc);
                    }
                    loc++;
                    i++;
                } else {
                    String op1 = input[i][0];
                    symTab[sn] = new SymTab(sn, op1, loc);
                    sn++;
                    String op2 = input[i][3];
                    int temp = comp(op1, symTab, sn);
                    if (temp != 99) {
                        symTab[temp] = new SymTab(temp, op1, loc);
                    }
                    loc++;
                    i++;
                }
            } else if (check(m) == 4) {
                poolTab[pn] = new PoolTab(pn, ln);
                pn++;
                while (Inc != ln) {
                    litTab[Inc].setAddr(loc);
                    Inc++;
                    loc++;
                }
                i++;
            }
            m = input[i][1];
        }

        System.out.println("Symbol Table");
        System.out.println("Index\tSymbol\tAddress");
        for (i = 0; i < sn; i++) {
            System.out.println(symTab[i].index + "\t" + symTab[i].name + "\t" + symTab[i].addr);
        }

        System.out.println("\nLiteral Table");
        System.out.println("Index\tLiteral\tAddress");
        for (i = 0; i < ln; i++) {
            System.out.println(litTab[i].index + "\t" + litTab[i].name + "\t" + litTab[i].addr);
        }

        System.out.println("\nPool Table");
        System.out.println("Pool Index\tLiteral Index");
        for (i = 0; i < pn; i++) {
            System.out.println("\t" + poolTab[i].pIndex + "\t\t" + poolTab[i].lIndex);
        }

        System.out.println("\n\nIntermediate Code\n");
        i = 0;
        m = input[i][1];
        String op1 = input[i][2];
        String op2 = input[i][3];
        int point = 0, in1 = 0, in2 = 0, j = 0;

        System.out.print(ic(m) + ic(op1));
        while (!m.equals("END")) {
            if (check(m) == 1) {
                System.out.print(ic(m) + ic(op1));
                if (comp(op2, symTab, sn) == 0 && comp(op2, symTab, sn) == 99) {
                    System.out.print(ic(op2));
                } else if (comp(op2, symTab, sn) == 2) {
                    int temp = comp(op2, litTab, ln);
                    System.out.print("(L." + temp + ")");
                    j++;
                } else if (comp(op2, symTab, sn) != 1) {
                    int temp = comp(op2, symTab, sn);
                    System.out.print("(S," + temp + ")");
                }
            } else if (check(m) == 2 || check(m) == 3) {
                System.out.print(ic(m) + ic(op2));
                if (comp(op1, symTab, sn) != 1) {
                    int temp = comp(op1, symTab, sn);
                    System.out.print("(S," + temp + ")");
                }
            } else if (check(m) == 4) {
                if (point + 1 != pn) {
                    in1 = poolTab[point + 1].lIndex - poolTab[point].lIndex;
                    in2 = poolTab[point].lIndex;
                    point++;
                    while (in1 > 0) {
                        System.out.print(ic(m) + ic(litTab[in2].name));
                        in2++;
                        in1--;
                    }
                } else {
                    in2 = poolTab[point].lIndex;
                    while (in2 != ln) {
                        System.out.print(ic(m) + ic(litTab[in2].name));
                        in2++;
                    }
                }
            }
            i++;
            m = input[i][1];
            op1 = input[i][2];
            op2 = input[i][3];
            System.out.print("\n");
        }

        System.out.println(ic(m));
    }

    static int check(String m) {
        if (m.equals("MOVER") || m.equals("ADD")) {
            return 1;
        } else if (m.equals("DS")) {
            return 2;
        } else if (m.equals("DC")) {
            return 3;
        } else if (m.equals("LTORG")) {
            return 4;
        }
        return -1;
    }

    static int comp(String m, SymTab[] s, int sn) {
        if (m.equals("AREG") || m.equals("BREG") || m.equals("CREG"))
            return 0;
        else if (m.charAt(0) == '=')
            return 2;
        else if (m.charAt(0) == 'L')
            return 99;
        for (int i = 0; i < sn; i++) {
            if (m.equals(s[i].name)) {
                return 1;
            }
        }
        return 99;
    }

    static int comp(String m, LitTab[] l, int ln) {
        for (int i = 0; i < ln; i++) {
            if (m.equals(l[i].name)) {
                return i;
            }
        }
        return -1;
    }

    static String ic(String m) {
        switch (m) {
            case "MOVER": return "00 ";
            case "ADD": return "01 ";
            case "SUB": return "02 ";
            case "MULT": return "03 ";
            case "DIV": return "04 ";
            case "LTORG": return "05 ";
            case "DC": return "06 ";
            case "DS": return "07 ";
            case "START": return "08 ";
            case "END": return "09 ";
            default: return m + " ";
        }
    }
}
----------------------12]pass2 -assembler---------------------------------------
import java.text.DecimalFormat;

class SymTab {
    int index;
    String name;
    int addr;

    SymTab(int i, String s, int a) {
        index = i;
        name = s;
        addr = a;
    }
}

class LitTab {
    int index;
    String name;
    int addr;

    LitTab(int i, String s, int a) {
        index = i;
        name = s;
        addr = a;
    }

    void setAddr(int a) {
        addr = a;
    }
}

public class Pass2 {
    public static void main(String[] args) {
        String[][] ic = {
            {"(AD,01)", null, "(C,100)"},
            {"(IS,04)", "(RG,01)", "(L,0)"}, 
            {"(IS,01)", "(RG,03)", "(L,1)"}, 
            {"(DL,01)", null, "(C,3)"}, 
            {"(IS,04)", "(RG,01)", "(S,2)"}, 
            {"(IS,01)", "(RG,01)", "(S,3)"}, 
            {"(IS,05)", "(RG,01)", "(S,4)"}, 
            {"(DL,02)", null, "(C,5)"}, 
            {"(DL,02)", null, "(C,1)"}, 
            {"(AD,04)", null, "(C,103)"}, 
            {"(IS,10)", null, "(S,4)"}, 
            {"(AD,03)", null, "(C,101)"}, 
            {"(IS,02)", "(RG,01)", "(L,2)"}, 
            {"(IS,03)", "(RG,03)", "(S,2)"}, 
            {"(DL,02)", null, "(C,5)"}, 
            {"(AD,03)", null, "(C,111)"}, 
            {"(IS,00)", null, null}, 
            {"(DL,02)", null, "(C,19)"}, 
            {"(AD,02)", null, null}, 
            {"(DL,02)", null, "(C,1)"}
        };

        SymTab[] s = new SymTab[20];
        LitTab[] l = new LitTab[20];

        // Initialize symbol and literal tables
        s[0] = new SymTab(0, "A", 102);
        s[1] = new SymTab(1, "LI", 105);
        s[2] = new SymTab(2, "B", 112);
        s[3] = new SymTab(3, "C", 103);
        s[4] = new SymTab(4, "D", 103);

        l[0] = new LitTab(0, "='5'", 108);
        l[1] = new LitTab(1, "='1'", 109);
        l[2] = new LitTab(2, "='1'", 113);

        int i = 0, j = 0, ind = 0;
        String m, op1, op2, temp;
        char[] arr1, arr2, arr3;

        DecimalFormat df = new DecimalFormat("000");

        while (i < ic.length) {
            temp = null;
            arr1 = null;
            arr2 = null;
            arr3 = null;
            m = ic[i][0];
            op1 = ic[i][1];
            op2 = ic[i][2];

            arr1 = m.toCharArray();
            if (op1 != null) {
                arr2 = op1.toCharArray();
            }
            if (op2 != null) {
                arr3 = op2.toCharArray();
            }

            if (arr1[1] == 'I' && arr1[2] == 'S') {
                // Print first two columns for IS
                System.out.print(arr1[4] + "" + arr1[5] + "\t");
                System.out.print((op1 != null ? arr2[4] + "" + arr2[5] : "00") + "\t");

                if (op2 != null) {
                    if (arr3[1] == 'R' && arr3[2] == 'G') {
                        System.out.print(arr3[4] + "" + arr3[5] + "\t");
                    } else if (arr3[1] == 'S') {
                        ind = Character.getNumericValue(arr3[3]);
                        j = 4;
                        while (arr3[j] != ')') {
                            ind = ind * 10 + Character.getNumericValue(arr3[j]);
                            j++;
                        }
                        System.out.print(s[ind].addr + "\t");
                    } else if (arr3[1] == 'L') {
                        ind = Character.getNumericValue(arr3[3]);
                        j = 4;
                        while (arr3[j] != ')') {
                            ind = ind * 10 + Character.getNumericValue(arr3[j]);
                            j++;
                        }
                        System.out.print(l[ind].addr + "\t");
                    }
                }
                System.out.print("\n"); // Ensure newline for IS entries
            } else if (arr1[1] == 'D' && arr1[2] == 'L') {
                if (arr1[5] == '2') {
                    System.out.print("00\t00\t");
                    j = 3;
                    while (arr3[j] != ')') {
                        if (temp == null) {
                            temp = String.valueOf(arr3[j]);
                        } else {
                            temp = temp.concat(String.valueOf(arr3[j]));
                        }
                        j++;
                    }
                    System.out.print(df.format(Integer.parseInt(temp)) + "\n");
                }
            }
            i++;
        }
    }
}
-------------------13]pass-1 micro-processor----------------------------
class MNT {
    int index;
    String name;
    int defIndex;

    MNT(int i, String a, int j) {
        index = i;
        name = a;
        defIndex = j;
    }
}

class MDT {
    int index;
    String[] def;

    MDT() {
        index = 0;
        def = new String[4];
    }

    void print() {
        for (String s : def) {
            if (s != null) {
                System.out.print(s + " ");
            }
        }
        System.out.println();
    }
}

public class Pass1Macro {
    public static void main(String[] args) {
        String[][] input = {
            {"MACRO", "INCR", "&A", "&B", "&REC"},
            {null, "MOVER", "&REG", "&A", null},
            {null, "ADDS", "&A", "&B", null},
            {null, "MOVEM", "&REG", "&A", null},
            {"MEND", null, null, null, null},
            {"MACRO", "ADDS", "&F", "&S", null},
            {null, "MOVER", "AREG", "&F", null},
            {null, "ADD", "AREG", "&S", null},
            {null, "MOVEM", "AREG", "&S", null},
            {null, "WRITE", "&S", null, null},
            {"MEND", null, null, null, null},
            {"MACRO", "SUBS", "&F", "&S", null},
            {null, "MOVER", "BREG", "&F", null},
            {null, "SUB", "BREG", "&S", null},
            {null, "MOVEM", "BREG", "&S", null},
            {null, "WRITE", "&S", null, null},
            {"MEND", null, null, null, null},
            {null, "START", null, "200", null},
            {null, "READ", "N1", null, null},
            {null, "READ", "N2", null, null},
            {null, "ADDS", "N1", "N2", null},
            {null, "SUBS", "N1", "N2", null},
            {null, "INCR", "N1", "N2", "DREG"},
            {null, "STOP", null, null, null},
            {"N1", "DS", "2", null, null},
            {"N2", "DS", "2", null, null},
            {null, "END", null, null, null}
        };

        MNT[] n = new MNT[20];
        MDT[] d = new MDT[20];

        int i = 0, nc = 0, dc = 0;

        while (i < input.length) {
            String arr1 = null, arr2 = null, arr3 = null, arr4 = null, arr5 = null;

            if (input[i][0] != null) arr1 = input[i][0];
            if (input[i][1] != null) arr2 = input[i][1];
            if (input[i][2] != null) arr3 = input[i][2];
            if (input[i][3] != null) arr4 = input[i][3];
            if (input[i][4] != null) arr5 = input[i][4];

            if ("MACRO".equals(arr1)) {
                n[nc] = new MNT(nc, arr2, dc);
                nc++;

                while (!"MEND".equals(arr1)) {
                    d[dc] = new MDT();
                    d[dc].index = dc;
                    d[dc].def[0] = arr2;

                    if (arr3 != null) {
                        d[dc].def[1] = arr3;
                    }
                    if (arr4 != null) {
                        d[dc].def[2] = arr4;
                    }
                    if (arr5 != null) {
                        d[dc].def[3] = arr5;
                    }

                    dc++;
                    i++;
                    if (i < input.length) {
                        arr1 = input[i][0];
                        arr2 = input[i][1];
                        arr3 = input[i][2];
                        arr4 = input[i][3];
                        arr5 = input[i][4];
                    } else {
                        break;
                    }
                }
            }

            if ("MEND".equals(arr1)) {
                d[dc] = new MDT();
                d[dc].index = dc;
                d[dc].def[0] = arr1;
                dc++;
            }

            i++;
        }

        System.out.print("MNT\nIndex\tName\tMDT_Index\n");
        for (i = 0; i < nc; i++) {
            System.out.println(n[i].index + "\t" + n[i].name + "\t" + n[i].defIndex);
        }

        System.out.print("\nMDT\nIndex\tDefinition\n");
        for (i = 0; i < dc; i++) {
            System.out.print(d[i].index + "\t");
            d[i].print();
        }
    }
}


------------------------------14]pass2-microprocessor----------------------------------
import java.util.ArrayList;

class MNT {
    int index;
    String name;
    int defIndex;

    MNT(int i, String a, int j) {
        index = i;
        name = a;
        defIndex = j;
    }
}

class MDT {
    int index;
    String[] def;

    MDT(int i, String m, String op1, String op2, String op3) {
        index = i;
        def = new String[4];
        def[0] = m;
        def[1] = op1;
        def[2] = op2;
        def[3] = op3;
    }
}

public class Pass2Macro {
    public static void main(String[] args) {
        // Example MNT and MDT from the first pass
        MNT[] mnt = new MNT[3];
        mnt[0] = new MNT(0, "INCR", 0);
        mnt[1] = new MNT(1, "ADDS", 5);
        mnt[2] = new MNT(2, "SUBS", 11);

        MDT[] mdt = new MDT[20];
        mdt[0] = new MDT(0, "INCR", "&A", "&B", "&REG");
        mdt[1] = new MDT(1, "MOVER", "#3", "#1", null);
        mdt[2] = new MDT(2, "ADDS", "#1", "#2", null);
        mdt[3] = new MDT(3, "MOVEM", "#3", "#1", null);
        mdt[4] = new MDT(4, "MEND", null, null, null);
        mdt[5] = new MDT(5, "ADDS", "&F", "&S", null);
        mdt[6] = new MDT(6, "MOVER", "AREG", "#1", null);
        mdt[7] = new MDT(7, "ADD", "AREG", "#2", null);
        mdt[8] = new MDT(8, "MOVEM", "AREG", "#2", null);
        mdt[9] = new MDT(9, "WRITE", "#2", null, null);
        mdt[10] = new MDT(10, "MEND", null, null, null);
        mdt[11] = new MDT(11, "SUBS", "&F", "&S", null);
        mdt[12] = new MDT(12, "MOVER", "BREG", "#1", null);
        mdt[13] = new MDT(13, "SUB", "BREG", "#2", null);
        mdt[14] = new MDT(14, "MOVEM", "BREG", "#2", null);
        mdt[15] = new MDT(15, "WRITE", "#2", null, null);
        mdt[16] = new MDT(16, "MEND", null, null, null);

        String[][] inputProgram = {
            {null, "START", null, "200", null},
            {null, "READ", "N1", null, null},
            {null, "READ", "N2", null, null},
            {null, "INCR", "N1", "N2", "DREG"},
            {null, "STOP", null, null, null},
            {"N1", "DS", "2", null, null},
            {"N2", "DS", "2", null, null},
            {null, "END", null, null, null}
        };

        ArrayList<String[]> outputProgram = new ArrayList<>();

        for (String[] line : inputProgram) {
            if (line[1] != null) {
                String macroName = line[1];
                MNT macro = findMacro(mnt, macroName);
                if (macro != null) {
                    int mdtIndex = macro.defIndex;

                    while (mdtIndex < mdt.length) {
                        if (mdt[mdtIndex].def[0].equals("MEND")) {
                            break; // Exit on "MEND"
                        }

                        String[] newLine = new String[5];
                        newLine[0] = line[0]; // Copy the label if it exists
                        newLine[1] = mdt[mdtIndex].def[0]; // Opcode

                        // Handle parameters
                        for (int i = 1; i <= 3; i++) {
                            if (mdt[mdtIndex].def[i] != null) {
                                if (mdt[mdtIndex].def[i].startsWith("&")) {
                                    // Replace parameter placeholders
                                    newLine[i + 1] = line[i]; 
                                } else {
                                    newLine[i + 1] = mdt[mdtIndex].def[i]; // Use the defined value
                                }
                            }
                        }

                        outputProgram.add(newLine);
                        mdtIndex++; // Move to the next MDT entry
                    }
                } else {
                    // If not a macro, add the line as it is
                    outputProgram.add(line);
                }
            } else {
                outputProgram.add(line);
            }
        }

        // Print the output program
        System.out.println("Output Program:");
        for (String[] outLine : outputProgram) {
            for (String s : outLine) {
                if (s != null) {
                    System.out.print(s + "\t");
                }
            }
            System.out.println();
        }
    }

    private static MNT findMacro(MNT[] mnt, String macroName) {
        for (MNT macro : mnt) {
            if (macro != null && macro.name.equals(macroName)) {
                return macro;
            }
        }
        return null; // Not found
    }
}